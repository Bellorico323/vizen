// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bills.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createBill = `-- name: CreateBill :one
INSERT INTO bills (
  condominium_id,
  apartment_id,
  bill_type,
  value_in_cents,
  due_date,
  digitable_line,
  pix_code,
  status
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  'pending'
) RETURNING id, condominium_id, apartment_id, bill_type, value_in_cents, due_date, paid_at, created_at, updated_at, digitable_line, pix_code, status
`

type CreateBillParams struct {
	CondominiumID uuid.UUID `json:"condominium_id"`
	ApartmentID   uuid.UUID `json:"apartment_id"`
	BillType      string    `json:"bill_type"`
	ValueInCents  int64     `json:"value_in_cents"`
	DueDate       time.Time `json:"due_date"`
	DigitableLine *string   `json:"digitable_line"`
	PixCode       *string   `json:"pix_code"`
}

func (q *Queries) CreateBill(ctx context.Context, arg CreateBillParams) (Bill, error) {
	row := q.db.QueryRow(ctx, createBill,
		arg.CondominiumID,
		arg.ApartmentID,
		arg.BillType,
		arg.ValueInCents,
		arg.DueDate,
		arg.DigitableLine,
		arg.PixCode,
	)
	var i Bill
	err := row.Scan(
		&i.ID,
		&i.CondominiumID,
		&i.ApartmentID,
		&i.BillType,
		&i.ValueInCents,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DigitableLine,
		&i.PixCode,
		&i.Status,
	)
	return i, err
}

const getBillById = `-- name: GetBillById :one
SELECT
  id, condominium_id, apartment_id, bill_type, value_in_cents, due_date, paid_at, created_at, updated_at, digitable_line, pix_code, status
FROM bills
WHERE id = $1
  AND condominium_id = $2
  AND status <> 'cancelled'
LIMIT 1
`

type GetBillByIdParams struct {
	ID            uuid.UUID `json:"id"`
	CondominiumID uuid.UUID `json:"condominium_id"`
}

func (q *Queries) GetBillById(ctx context.Context, arg GetBillByIdParams) (Bill, error) {
	row := q.db.QueryRow(ctx, getBillById, arg.ID, arg.CondominiumID)
	var i Bill
	err := row.Scan(
		&i.ID,
		&i.CondominiumID,
		&i.ApartmentID,
		&i.BillType,
		&i.ValueInCents,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DigitableLine,
		&i.PixCode,
		&i.Status,
	)
	return i, err
}

const listBills = `-- name: ListBills :many
SELECT
  id, condominium_id, apartment_id, bill_type, value_in_cents, due_date, paid_at, created_at, updated_at, digitable_line, pix_code, status
FROM bills
WHERE condominium_id = $1
  AND ($4::uuid IS NULL OR apartment_id = $4::uuid)
  AND ($5::varchar IS NULL OR status = $5)
ORDER BY due_date ASC
LIMIT $2 OFFSET $3
`

type ListBillsParams struct {
	CondominiumID uuid.UUID  `json:"condominium_id"`
	Limit         int32      `json:"limit"`
	Offset        int32      `json:"offset"`
	ApartmentID   *uuid.UUID `json:"apartment_id"`
	Status        *string    `json:"status"`
}

func (q *Queries) ListBills(ctx context.Context, arg ListBillsParams) ([]Bill, error) {
	rows, err := q.db.Query(ctx, listBills,
		arg.CondominiumID,
		arg.Limit,
		arg.Offset,
		arg.ApartmentID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bill
	for rows.Next() {
		var i Bill
		if err := rows.Scan(
			&i.ID,
			&i.CondominiumID,
			&i.ApartmentID,
			&i.BillType,
			&i.ValueInCents,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DigitableLine,
			&i.PixCode,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBillsByApartmentId = `-- name: ListBillsByApartmentId :many
SELECT
  id, condominium_id, apartment_id, bill_type, value_in_cents, due_date, paid_at, created_at, updated_at, digitable_line, pix_code, status
FROM bills
WHERE apartment_id = $1
  AND condominium_id = $2
  AND status <> 'cancelled'
ORDER BY due_date ASC
`

type ListBillsByApartmentIdParams struct {
	ApartmentID   uuid.UUID `json:"apartment_id"`
	CondominiumID uuid.UUID `json:"condominium_id"`
}

func (q *Queries) ListBillsByApartmentId(ctx context.Context, arg ListBillsByApartmentIdParams) ([]Bill, error) {
	rows, err := q.db.Query(ctx, listBillsByApartmentId, arg.ApartmentID, arg.CondominiumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bill
	for rows.Next() {
		var i Bill
		if err := rows.Scan(
			&i.ID,
			&i.CondominiumID,
			&i.ApartmentID,
			&i.BillType,
			&i.ValueInCents,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DigitableLine,
			&i.PixCode,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBillsByCondominiumId = `-- name: ListBillsByCondominiumId :many
SELECT
  id, condominium_id, apartment_id, bill_type, value_in_cents, due_date, paid_at, created_at, updated_at, digitable_line, pix_code, status
FROM bills
WHERE condominium_id = $1
  AND ($4::varchar IS NOT NULL OR status = $4)
ORDER BY due_date DESC
LIMIT $2 OFFSET $3
`

type ListBillsByCondominiumIdParams struct {
	CondominiumID uuid.UUID `json:"condominium_id"`
	Limit         int32     `json:"limit"`
	Offset        int32     `json:"offset"`
	Status        *string   `json:"status"`
}

func (q *Queries) ListBillsByCondominiumId(ctx context.Context, arg ListBillsByCondominiumIdParams) ([]Bill, error) {
	rows, err := q.db.Query(ctx, listBillsByCondominiumId,
		arg.CondominiumID,
		arg.Limit,
		arg.Offset,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bill
	for rows.Next() {
		var i Bill
		if err := rows.Scan(
			&i.ID,
			&i.CondominiumID,
			&i.ApartmentID,
			&i.BillType,
			&i.ValueInCents,
			&i.DueDate,
			&i.PaidAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DigitableLine,
			&i.PixCode,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBillStatus = `-- name: UpdateBillStatus :one
UPDATE bills
SET
  status = $1,
  paid_at = CASE WHEN $1::VARCHAR(50) = 'paid' THEN NOW() ELSE NULL END,
  updated_at = NOW()
WHERE id = $2 AND condominium_id = $3
RETURNING id, condominium_id, apartment_id, bill_type, value_in_cents, due_date, paid_at, created_at, updated_at, digitable_line, pix_code, status
`

type UpdateBillStatusParams struct {
	Status        string    `json:"status"`
	ID            uuid.UUID `json:"id"`
	CondominiumID uuid.UUID `json:"condominium_id"`
}

func (q *Queries) UpdateBillStatus(ctx context.Context, arg UpdateBillStatusParams) (Bill, error) {
	row := q.db.QueryRow(ctx, updateBillStatus, arg.Status, arg.ID, arg.CondominiumID)
	var i Bill
	err := row.Scan(
		&i.ID,
		&i.CondominiumID,
		&i.ApartmentID,
		&i.BillType,
		&i.ValueInCents,
		&i.DueDate,
		&i.PaidAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DigitableLine,
		&i.PixCode,
		&i.Status,
	)
	return i, err
}
