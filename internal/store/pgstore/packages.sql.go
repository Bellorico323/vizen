// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: packages.sql

package pgstore

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createPackage = `-- name: CreatePackage :one
INSERT INTO packages (
  condominium_id,
  apartment_id,
  received_by,
  recipient_name,
  photo_url,
  status
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  'pending'
) RETURNING id, condominium_id, apartment_id, received_by, received_at, recipient_name, photo_url, status, withdrawn_at, withdrawn_by
`

type CreatePackageParams struct {
	CondominiumID uuid.UUID `json:"condominium_id"`
	ApartmentID   uuid.UUID `json:"apartment_id"`
	ReceivedBy    uuid.UUID `json:"received_by"`
	RecipientName *string   `json:"recipient_name"`
	PhotoUrl      *string   `json:"photo_url"`
}

func (q *Queries) CreatePackage(ctx context.Context, arg CreatePackageParams) (Package, error) {
	row := q.db.QueryRow(ctx, createPackage,
		arg.CondominiumID,
		arg.ApartmentID,
		arg.ReceivedBy,
		arg.RecipientName,
		arg.PhotoUrl,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.CondominiumID,
		&i.ApartmentID,
		&i.ReceivedBy,
		&i.ReceivedAt,
		&i.RecipientName,
		&i.PhotoUrl,
		&i.Status,
		&i.WithdrawnAt,
		&i.WithdrawnBy,
	)
	return i, err
}

const getPackageById = `-- name: GetPackageById :one
SELECT
  p.id, p.condominium_id, p.apartment_id, p.received_by, p.received_at, p.recipient_name, p.photo_url, p.status, p.withdrawn_at, p.withdrawn_by,
  a.block,
  a.number AS apartment_number,
  u.name AS received_by_name
FROM packages p
JOIN apartments a ON a.id = p.apartment_id
JOIN users u ON u.id = p.received_by
WHERE p.id = $1
`

type GetPackageByIdRow struct {
	ID              uuid.UUID  `json:"id"`
	CondominiumID   uuid.UUID  `json:"condominium_id"`
	ApartmentID     uuid.UUID  `json:"apartment_id"`
	ReceivedBy      uuid.UUID  `json:"received_by"`
	ReceivedAt      time.Time  `json:"received_at"`
	RecipientName   *string    `json:"recipient_name"`
	PhotoUrl        *string    `json:"photo_url"`
	Status          string     `json:"status"`
	WithdrawnAt     *time.Time `json:"withdrawn_at"`
	WithdrawnBy     *uuid.UUID `json:"withdrawn_by"`
	Block           *string    `json:"block"`
	ApartmentNumber string     `json:"apartment_number"`
	ReceivedByName  string     `json:"received_by_name"`
}

func (q *Queries) GetPackageById(ctx context.Context, id uuid.UUID) (GetPackageByIdRow, error) {
	row := q.db.QueryRow(ctx, getPackageById, id)
	var i GetPackageByIdRow
	err := row.Scan(
		&i.ID,
		&i.CondominiumID,
		&i.ApartmentID,
		&i.ReceivedBy,
		&i.ReceivedAt,
		&i.RecipientName,
		&i.PhotoUrl,
		&i.Status,
		&i.WithdrawnAt,
		&i.WithdrawnBy,
		&i.Block,
		&i.ApartmentNumber,
		&i.ReceivedByName,
	)
	return i, err
}

const listPackagesByApartment = `-- name: ListPackagesByApartment :many
SELECT
  p.id,
  p.recipient_name,
  p.received_at,
  p.status,
  p.photo_url,
  u.name as received_by_name,
  p.withdrawn_at,
  p.withdrawn_by
FROM packages p
JOIN users u ON u.id = p.received_by
WHERE p.apartment_id = $1
  AND ($2::text IS NULL OR p.status = $2::text)
ORDER BY p.received_at DESC
`

type ListPackagesByApartmentParams struct {
	ApartmentID uuid.UUID `json:"apartment_id"`
	Status      *string   `json:"status"`
}

type ListPackagesByApartmentRow struct {
	ID             uuid.UUID  `json:"id"`
	RecipientName  *string    `json:"recipient_name"`
	ReceivedAt     time.Time  `json:"received_at"`
	Status         string     `json:"status"`
	PhotoUrl       *string    `json:"photo_url"`
	ReceivedByName string     `json:"received_by_name"`
	WithdrawnAt    *time.Time `json:"withdrawn_at"`
	WithdrawnBy    *uuid.UUID `json:"withdrawn_by"`
}

func (q *Queries) ListPackagesByApartment(ctx context.Context, arg ListPackagesByApartmentParams) ([]ListPackagesByApartmentRow, error) {
	rows, err := q.db.Query(ctx, listPackagesByApartment, arg.ApartmentID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPackagesByApartmentRow
	for rows.Next() {
		var i ListPackagesByApartmentRow
		if err := rows.Scan(
			&i.ID,
			&i.RecipientName,
			&i.ReceivedAt,
			&i.Status,
			&i.PhotoUrl,
			&i.ReceivedByName,
			&i.WithdrawnAt,
			&i.WithdrawnBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackagesByCondominium = `-- name: ListPackagesByCondominium :many
SELECT
  p.id,
  p.recipient_name,
  p.received_at,
  p.status,
  a.block,
  a.number as apartment_number,
  p.withdrawn_at,
  p.withdrawn_by
FROM packages p
JOIN apartments a ON a.id = p.apartment_id
WHERE p.condominium_id = $1
  AND ($2::text IS NULL OR p.status = $2::text)
ORDER BY p.received_at DESC
`

type ListPackagesByCondominiumParams struct {
	CondominiumID uuid.UUID `json:"condominium_id"`
	Status        *string   `json:"status"`
}

type ListPackagesByCondominiumRow struct {
	ID              uuid.UUID  `json:"id"`
	RecipientName   *string    `json:"recipient_name"`
	ReceivedAt      time.Time  `json:"received_at"`
	Status          string     `json:"status"`
	Block           *string    `json:"block"`
	ApartmentNumber string     `json:"apartment_number"`
	WithdrawnAt     *time.Time `json:"withdrawn_at"`
	WithdrawnBy     *uuid.UUID `json:"withdrawn_by"`
}

func (q *Queries) ListPackagesByCondominium(ctx context.Context, arg ListPackagesByCondominiumParams) ([]ListPackagesByCondominiumRow, error) {
	rows, err := q.db.Query(ctx, listPackagesByCondominium, arg.CondominiumID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPackagesByCondominiumRow
	for rows.Next() {
		var i ListPackagesByCondominiumRow
		if err := rows.Scan(
			&i.ID,
			&i.RecipientName,
			&i.ReceivedAt,
			&i.Status,
			&i.Block,
			&i.ApartmentNumber,
			&i.WithdrawnAt,
			&i.WithdrawnBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePackageToWithdrawn = `-- name: UpdatePackageToWithdrawn :one
UPDATE packages
SET
  status = 'withdrawn',
  withdrawn_at = NOW(),
  withdrawn_by = $2
WHERE id = $1
RETURNING id, condominium_id, apartment_id, received_by, received_at, recipient_name, photo_url, status, withdrawn_at, withdrawn_by
`

type UpdatePackageToWithdrawnParams struct {
	ID          uuid.UUID  `json:"id"`
	WithdrawnBy *uuid.UUID `json:"withdrawn_by"`
}

func (q *Queries) UpdatePackageToWithdrawn(ctx context.Context, arg UpdatePackageToWithdrawnParams) (Package, error) {
	row := q.db.QueryRow(ctx, updatePackageToWithdrawn, arg.ID, arg.WithdrawnBy)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.CondominiumID,
		&i.ApartmentID,
		&i.ReceivedBy,
		&i.ReceivedAt,
		&i.RecipientName,
		&i.PhotoUrl,
		&i.Status,
		&i.WithdrawnAt,
		&i.WithdrawnBy,
	)
	return i, err
}
